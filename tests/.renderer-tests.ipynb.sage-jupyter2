{"backend_state":"ready","kernel":"python3","kernel_state":"idle","kernel_usage":{"cpu":0,"memory":0},"last_ipynb_save":1706596075437,"type":"settings"}
{"cell_type":"code","exec_count":12,"id":"ecb401","input":"class Line:\n    def __init__(self, v1, v2):\n        self.v1 = v1\n        self.v2 = v2\n\n        self.steep = False\n        self.realSlope = 0\n        if (abs(self.v1.x - self.v2.x) < abs(self.v1.y - self.v2.y)):\n            self.realSlope = (self.v2.y - self.v1.y) / (self.v2.x - self.v1.x)\n            self.realYIntercept = self.v1.y - (self.realSlope * self.v1.x)\n            self.v1.x, self.v1.y = self.v1.y, self.v1.x\n            self.v2.x, self.v2.y = self.v2.y, self.v2.x\n            self.steep = True\n        if (self.v1.x > self.v2.x):\n            self.v1, self.v2 = self.v2, self.v1\n        self.slope = (self.v2.y - self.v1.y) / (self.v2.x - self.v1.x)\n        self.yIntercept = self.v1.y - (self.slope * self.v1.x)\n    def getSlope(self):\n        #if (self.steep):\n        #    return (self.v2.x - self.v1.x) / (self.v2.y - self.v1.y)\n        #else:\n        #    return self.slope\n        return self.realSlope if self.steep else self.slope\n    def getYIntercept(self):\n        return self.realYIntercept if self.steep else self.yIntercept\n# Lets stop with the line class, we don't need it for this \"quick\" test\nclass Triangle:\n\n    def __init__(self, v1, v2, v3):\n        # For now, assume that the vectors are sorted by y\n        self.v1 = v1\n        self.v2 = v2\n        self.v3 = v3\n\n\n\n\n\n    def area(self):\n        pass\n\n\ntri = Triangle(Vec2(2, 3), Vec2(3, 4), Vec2(4, 5))\nprint(tri.v1)\nline = Line(Vec2(3, 2), Vec2(4, 4))\nprint(f\"{line.getSlope()} {line.getYIntercept()}\")","metadata":{"deletable":true,"editable":true},"output":{"0":{"name":"stdout","output_type":"stream","text":"Vec2(2,3)\n2.0 -4.0\n"}},"pos":4,"type":"cell"}
{"cell_type":"code","exec_count":3,"id":"4dd93c","input":"import matplotlib.pyplot as plt\nimport numpy as np\nimport math","pos":0,"type":"cell"}
{"cell_type":"code","exec_count":4,"id":"e1d520","input":"class Vec2:\n    def __init__(self, inputX, inputY):\n        self.x = inputX\n        self.y = inputY\n    def __str__(self):\n        return f\"Vec2({self.x},{self.y})\"\n\nmyVec = Vec2(2, 3)\n\nprint(myVec)","metadata":{"deletable":true,"editable":true},"output":{"0":{"name":"stdout","output_type":"stream","text":"Vec2(2,3)\n"}},"pos":1,"type":"cell"}
{"cell_type":"code","exec_count":5,"id":"6cd956","input":"#plt.style.use('_mpl-gallery')\n\n# make the data\nnp.random.seed(3)\nx = 4 + np.random.normal(0, 2, 24)\ny = 4 + np.random.normal(0, 2, len(x))\n# size and color:\nsizes = np.random.uniform(15, 80, len(x))\ncolors = np.random.uniform(15, 80, len(x))\n\n# plot\nfig, ax = plt.subplots()\n\nax.scatter(x, y, s=sizes, c=colors, vmin=0, vmax=100)\n\nax.set(xlim=(0, 8), xticks=np.arange(1, 8),\n       ylim=(0, 8), yticks=np.arange(1, 8))\n\nplt.show()","output":{"0":{"data":{"image/png":"97b20572e29de4a23b62cd18ec4773d52533a3a2","text/plain":"<Figure size 864x504 with 1 Axes>"},"exec_count":5,"metadata":{"image/png":{"height":411,"width":697},"needs_background":"light"},"output_type":"execute_result"}},"pos":2,"type":"cell"}
{"cell_type":"code","exec_count":6,"id":"12aa28","input":"fig, ax= plt.subplots()\nax.scatter([2, 3, 4], [2, 3, 4])\nplt.show()","output":{"0":{"data":{"image/png":"b37528875fac319b0f75f8ca02851b5dc4127ee1","text/plain":"<Figure size 864x504 with 1 Axes>"},"exec_count":6,"metadata":{"image/png":{"height":411,"width":713},"needs_background":"light"},"output_type":"execute_result"}},"pos":3,"type":"cell"}
{"id":0,"time":1706595840986,"type":"user"}
{"last_load":1706595840916,"type":"file"}